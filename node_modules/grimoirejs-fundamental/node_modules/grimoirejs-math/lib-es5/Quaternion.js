"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = require("./Vector3");

var _Vector2 = _interopRequireDefault(_Vector);

var _glMatrix = require("gl-matrix");

var _Matrix = require("./Matrix");

var _Matrix2 = _interopRequireDefault(_Matrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* The class to maniplate quaternion.
* Basically,you don't need to operate raw element.
* You consider to use some of useful methods without editing raw element forcelly.
* Each element will be represented as (w;x,y,z)
* (1,i,j,k) is base axis for quaternion. (i,j,k is pure imaginary number)
* (w;x,y,z) means w*1+x*i+y*j+z*k
*
*/
var Quaternion = function () {
    /**
    * Constructor by specifing each elements.
    */
    function Quaternion(rawElements) {
        _classCallCheck(this, Quaternion);

        this.rawElements = rawElements;
    }

    _createClass(Quaternion, [{
        key: "equalWith",
        value: function equalWith(q) {
            return Quaternion.equals(this, q);
        }
        /**
        * Get normalized quaternion
        */

    }, {
        key: "normalize",
        value: function normalize() {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.normalize(newQuat, this.rawElements));
        }
    }, {
        key: "inverse",
        value: function inverse() {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.invert(newQuat, this.rawElements));
        }
    }, {
        key: "toAngleAxisString",
        value: function toAngleAxisString() {
            var angle = 2 * Math.acos(this.W);
            var imm = Math.sqrt(1 - this.W * this.W);
            if (angle !== 180 && angle !== 0) {
                return "axis(" + angle + "," + this.X / imm + "," + this.Y / imm + "," + this.Z / imm + ")";
            } else if (angle === 0) {
                return "axis(" + angle + ",0,1,0)";
            } else {
                return "axis(180d," + this.X + "," + this.Y + "," + this.Z + ")";
            }
        }
    }, {
        key: "toString",
        value: function toString() {
            return this.toAngleAxisString();
        }
    }, {
        key: "factoringQuaternionZXY",
        value: function factoringQuaternionZXY() {
            var result = { x: 0, y: 0, z: 0 };
            var mat = _Matrix2.default.rotationQuaternion(this);
            var sx = mat.rawElements[6];
            if (Math.abs(sx) < 1 - 1.0E-4) {
                result.x = Math.asin(sx);
                result.z = Math.atan2(-mat.rawElements[4], mat.rawElements[5]);
                result.y = Math.atan2(-mat.rawElements[2], mat.rawElements[10]);
            } else {
                result.y = 0;
                result.x = Math.PI / 2 * sx;
                result.z = Math.atan2(mat.rawElements[1], mat.rawElements[0]);
            }
            return result;
        }
    }, {
        key: "factoringQuaternionXYZ",
        value: function factoringQuaternionXYZ() {
            var result = { x: 0, y: 0, z: 0 };
            var mat = _Matrix2.default.rotationQuaternion(this);
            var sy = -mat.rawElements[2];
            if (Math.abs(sy) < 1 - 1.0E-4) {
                result.x = Math.atan2(mat.rawElements[6], mat.rawElements[10]);
                result.y = Math.asin(sy);
                result.z = Math.atan2(mat.rawElements[1], mat.rawElements[0]);
            } else {
                result.x = 0;
                result.y = Math.PI / 2 * sy;
                result.z = Math.atan2(-mat.rawElements[4], mat.rawElements[5]);
            }
            return result;
        }
    }, {
        key: "eularAngles",
        get: function get() {
            var eular = this.factoringQuaternionZXY();
            return new _Vector2.default(eular.x, eular.y, eular.z);
        },
        set: function set(v) {
            this.rawElements = Quaternion.euler(v.X, v.Y, v.Z).rawElements;
        }
        /**
        * Getter for X.
        */

    }, {
        key: "X",
        get: function get() {
            return this.rawElements[0];
        }
        /**
        * Getter for Y.
        */

    }, {
        key: "Y",
        get: function get() {
            return this.rawElements[1];
        }
        /**
        * Getter for Z.
        */

    }, {
        key: "Z",
        get: function get() {
            return this.rawElements[2];
        }
        /**
        * Getter for W.
        */

    }, {
        key: "W",
        get: function get() {
            return this.rawElements[3];
        }
        /**
        * Getter for imaginary part vector.
        * It returns the vector (x,y,z)
        */

    }, {
        key: "ImaginaryPart",
        get: function get() {
            return new _Vector2.default(this.X, this.Y, this.Z);
        }
        /**
        * Get the conjugate of this quaternion
        */

    }, {
        key: "Conjugate",
        get: function get() {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.conjugate(newQuat, this.rawElements));
        }
        /**
        * Get the length
        */

    }, {
        key: "Length",
        get: function get() {
            return _glMatrix.quat.len(this.rawElements);
        }
    }], [{
        key: "equals",
        value: function equals(q1, q2) {
            for (var i = 0; i < 4; i++) {
                if (q1.rawElements[i] !== q2.rawElements[i]) {
                    return false;
                }
            }
            return true;
        }
        /**
        * Calculate add result of two quaternion
        */

    }, {
        key: "add",
        value: function add(q1, q2) {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.add(newQuat, q1.rawElements, q2.rawElements));
        }
        /**
        * Calculate multiply result of two quaternion
        */

    }, {
        key: "multiply",
        value: function multiply(q1, q2) {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.mul(newQuat, q1.rawElements, q2.rawElements));
        }
        /**
        * Calculate the rotation quaternion represented as pair of angle and axis.
        */

    }, {
        key: "angleAxis",
        value: function angleAxis(angle, axis) {
            var axisVec = _glMatrix.vec3.create();
            axisVec[0] = axis.X;
            axisVec[1] = axis.Y;
            axisVec[2] = axis.Z;
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.setAxisAngle(newQuat, axisVec, +angle));
        }
    }, {
        key: "euler",
        value: function euler(x, y, z) {
            return Quaternion.multiply(Quaternion.angleAxis(z, _Vector2.default.ZUnit), Quaternion.multiply(Quaternion.angleAxis(x, _Vector2.default.XUnit), Quaternion.angleAxis(y, _Vector2.default.YUnit)));
        }
    }, {
        key: "eulerXYZ",
        value: function eulerXYZ(x, y, z) {
            return Quaternion.multiply(Quaternion.angleAxis(z, _Vector2.default.ZUnit), Quaternion.multiply(Quaternion.angleAxis(y, _Vector2.default.YUnit), Quaternion.angleAxis(x, _Vector2.default.XUnit)));
        }
    }, {
        key: "slerp",
        value: function slerp(q1, q2, t) {
            var newQuat = _glMatrix.quat.create();
            return new Quaternion(_glMatrix.quat.slerp(newQuat, q1.rawElements, q2.rawElements, +t));
        }
        /**
         * Returns the angle in degrees between two rotations q1 and q2.
         * @param q1 the quaternion represents begin angle.
         * @param q2 the quaternion represents end angle.
         * @returns {number} angle represented in radians.
         */

    }, {
        key: "angle",
        value: function angle(q1, q2) {
            var delta = Quaternion.multiply(q2, q1.inverse());
            delta = delta.normalize();
            return 2 * Math.acos(delta.W);
        }
    }, {
        key: "fromToRotation",
        value: function fromToRotation(from, to) {
            var crossed = _Vector2.default.cross(from.normalized, to.normalized);
            var angle = _Vector2.default.dot(from.normalized, to.normalized);
            return Quaternion.angleAxis(angle, crossed);
        }
    }, {
        key: "lookRotation",
        value: function lookRotation(forward, upVec) {
            upVec = upVec || _Vector2.default.YUnit;
            var normalizedForward = forward.normalized;
            var upForwardCross = _Vector2.default.cross(upVec, normalizedForward).normalized;
            var thirdAxis = _Vector2.default.cross(normalizedForward, upForwardCross);
            var m00 = upForwardCross.X;
            var m01 = upForwardCross.Y;
            var m02 = upForwardCross.Z;
            var m10 = thirdAxis.X;
            var m11 = thirdAxis.Y;
            var m12 = thirdAxis.Z;
            var m20 = normalizedForward.X;
            var m21 = normalizedForward.Y;
            var m22 = normalizedForward.Z;
            var num8 = m00 + m11 + m22;
            if (num8 > 0) {
                var num = Math.sqrt(1 + num8);
                return new Quaternion([(m12 - m21) * 0.5 / num, (m20 - m02) * 0.5 / num, (m01 - m10) * 0.5 / num, num / 2]);
            }
            if (m00 >= m11 && m00 >= m22) {
                var num7 = Math.sqrt(1 + m00 - m11 - m22);
                return new Quaternion([(m01 + m10) * 0.5 / num7, (m02 + m20) * 0.5 / num7, (m12 - m21) * 0.5 / num7, num7 / 2]);
            }
            if (m11 > m22) {
                var num6 = Math.sqrt(1 + m11 - m00 - m22);
                return new Quaternion([(m10 + m01) * 0, 5 / num6, 0.5 * num6, (m21 + m12) * 0.5 / num6, (m20 - m02) * 0.5 / num6]);
            }
            var num5 = Math.sqrt(1 + m22 - m00 - m11);
            return new Quaternion([(m20 + m02) * 0.5 / num5, (m21 + m12) * 0.5 / num5, 0.5 * num5, (m01 - m10) * 0.5 / num5]);
        }
    }, {
        key: "Identity",
        get: function get() {
            return new Quaternion(_glMatrix.quat.create());
        }
    }]);

    return Quaternion;
}();

exports.default = Quaternion;
//# sourceMappingURL=Quaternion.js.map