"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VectorBase = function () {
    function VectorBase() {
        _classCallCheck(this, VectorBase);

        this._magnitudeSquaredCache = -1;
        this._magnitudeCache = -1;
    }

    _createClass(VectorBase, [{
        key: "magnitude",
        get: function get() {
            if (this._magnitudeCache < 0) {
                this._magnitudeCache = Math.sqrt(this.sqrMagnitude);
            }
            return this._magnitudeCache;
        }
    }, {
        key: "ElementCount",
        get: function get() {
            return 0;
        }
    }, {
        key: "sqrMagnitude",
        get: function get() {
            if (this._magnitudeSquaredCache < 0) {
                var sum = 0;
                var r = this.rawElements;
                for (var i = 0; i < this.ElementCount; i++) {
                    sum += r[i] * r[i];
                }
                this._magnitudeSquaredCache = sum;
            }
            return this._magnitudeSquaredCache;
        }
    }], [{
        key: "__elementEquals",
        value: function __elementEquals(v1, v2) {
            if (v1.ElementCount !== v2.ElementCount) {
                return false;
            }
            for (var i = 0; i < v1.ElementCount; i++) {
                if (v1.rawElements[i] !== v2.rawElements[i]) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: "__nearlyElementEquals",
        value: function __nearlyElementEquals(v1, v2) {
            if (v1.ElementCount !== v2.ElementCount) {
                return false;
            }
            var error = 0.01;
            for (var i = 0; i < v1.ElementCount; i++) {
                if (Math.abs(v1.rawElements[i] - v2.rawElements[i]) > error) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: "__fromGenerationFunction",
        value: function __fromGenerationFunction(v1, v2, gen) {
            var f = new Float32Array(v1.ElementCount);
            for (var i = 0; i < f.length; i++) {
                f[i] = gen(i, v1, v2);
            }
            return f;
        }
    }, {
        key: "__parse",
        value: function __parse(str) {
            var checkRegex = /(-?)([\d,E\+\-\.]+)?(n)?\(([-\d,E\+\.\s]+)\)/g;
            var matches = checkRegex.exec(str);
            if (matches) {
                if (!matches[4]) {
                    throw new Error("The specified string '" + str + "' is not containing braced vector.");
                }
                return {
                    needNormalize: matches[3] === "n",
                    needNegate: matches[1] === "-",
                    coefficient: parseFloat(matches[2]),
                    elements: VectorBase._parseRawVector(matches[4])
                };
            } else {
                // Assume this is simplified format.
                return {
                    needNormalize: false,
                    needNegate: false,
                    elements: VectorBase._parseRawVector(str),
                    coefficient: undefined
                };
            }
        }
    }, {
        key: "_parseRawVector",
        value: function _parseRawVector(str) {
            var splitted = str.split(",");
            var result = new Array(splitted.length);
            for (var i = 0; i < splitted.length; i++) {
                result[i] = parseFloat(splitted[i]);
                if (isNaN(result[i])) {
                    throw new Error("Unexpected vector string " + str);
                }
            }
            return result;
        }
    }]);

    return VectorBase;
}();

exports.default = VectorBase;
//# sourceMappingURL=VectorBase.js.map