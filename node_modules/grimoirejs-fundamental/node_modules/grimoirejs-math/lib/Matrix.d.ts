import MatrixBase from "./MatrixBase";
import Vector3 from "./Vector3";
import Vector4 from "./Vector4";
import Quaternion from "./Quaternion";
import { GLM } from "gl-matrix";
declare class Matrix extends MatrixBase {
    static zero(): Matrix;
    static identity(): Matrix;
    static fromElements(m00: any, m01: any, m02: any, m03: any, m10: any, m11: any, m12: any, m13: any, m20: any, m21: any, m22: any, m23: any, m30: any, m31: any, m32: any, m33: any): Matrix;
    static fromFunc(f: (w: number, h: number) => number): Matrix;
    static equals(m1: Matrix, m2: Matrix): boolean;
    static add(m1: Matrix, m2: Matrix): Matrix;
    static subtract(m1: Matrix, m2: Matrix): Matrix;
    static scalarMultiply(s: number, m: Matrix): Matrix;
    static multiply(m1: Matrix, m2: Matrix): Matrix;
    static trs(t: Vector3, rot: Quaternion, s: Vector3): Matrix;
    static negate(m: Matrix): Matrix;
    static transpose(m: Matrix): Matrix;
    static transformPoint(m: Matrix, t: Vector3): Vector3;
    static transformNormal(m: Matrix, t: Vector3): Vector3;
    static transform(m: Matrix, t: Vector4): Vector4;
    /**
     * Retrieve determinant of passed matrix
     */
    static determinant(m: Matrix): number;
    /**
     * Compute inverted passed matrix.
     */
    static inverse(m: Matrix): Matrix;
    /**
     * Generate linear translation transform matrix.
     */
    static translate(v: Vector3): Matrix;
    /**
     * Generate linear scaling transform matrix.
     */
    static scale(v: Vector3): Matrix;
    static rotateX(angle: number): Matrix;
    static rotateY(angle: number): Matrix;
    static rotateZ(angle: number): Matrix;
    static rotationQuaternion(quat_: Quaternion): Matrix;
    static frustum(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix;
    static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix;
    static perspective(fovy: number, aspect: number, near: number, far: number): Matrix;
    static lookAt(eye: Vector3, lookAt: Vector3, up: Vector3): Matrix;
    constructor(arr?: GLM.IArray);
    getAt(row: number, colmun: number): number;
    setAt(row: number, colmun: number, val: number): void;
    getBySingleIndex(index: number): number;
    getColmun(col: number): Vector4;
    /**
    * Get row
    * @params row [0-3]
    */
    getRow(row: number): Vector4;
    multiplyWith(m: Matrix): Matrix;
    equalWith(m: Matrix): boolean;
    toString(): string;
    toMathematicaString(): string;
    readonly ElementCount: number;
    readonly RowCount: number;
    readonly ColmunCount: number;
}
export default Matrix;
