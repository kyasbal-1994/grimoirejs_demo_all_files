export default class GeometryUtility {
    /**
     * Generateor wrap for array
     * @param  {number[]}                 array [description]
     * @return {IterableIterator<number>}       [description]
     */
    static *fromArray(array) {
        for (let i = 0; i < array.length; i++) {
            yield array[i];
        }
    }
    /**
     * Convert triangles topology to lines. Basically uses for making wireframes.
     * @param  {IterableIterator<number>} indicies [description]
     * @return {IterableIterator<number>}          [description]
     */
    static *linesFromTriangles(indicies) {
        const ic = new Array(3);
        let i = 0;
        for (let index of indicies) {
            ic[i % 3] = index;
            if (i % 3 === 2) {
                const a = ic[0], b = ic[1], c = ic[2];
                yield* [a, b, b, c, c, a];
            }
            i++;
        }
    }
    /**
     * Generator for ellipse positions
     * @param  {Vector3}                  center [the center position of ellipse]
     * @param  {Vector3}                  up     [up vector for ellipse]
     * @param  {Vector3}                  right  [right vector for ellipse]
     * @param  {number}                   divide [how many triangles should consists in the ellipse]
     * @return {IterableIterator<number>}        [Generated iterator for position]
     */
    static *ellipsePosition(center, up, right, divide) {
        yield center.X;
        yield center.Y;
        yield center.Z;
        const step = 2 * Math.PI / divide;
        for (let i = 0; i < divide; i++) {
            const theta = step * i;
            const sin = Math.sin(theta);
            const cos = Math.cos(theta);
            yield center.X + cos * up.X + sin * right.X;
            yield center.Y + cos * up.Y + sin * right.Y;
            yield center.Z + cos * up.Z + sin * right.Z;
        }
    }
    static *ellipseIndex(offset, divide) {
        for (let i = 0; i < divide - 1; i++) {
            yield* [offset, offset + 1 + i, offset + 2 + i];
        }
        yield* [offset, offset + divide, offset + 1];
    }
    static ellipseSize(divide) {
        return divide + 1;
    }
    static *cubePosition(center, up, right, forward) {
        yield* GeometryUtility.quadPosition(center.subtractWith(forward), up, right); // 手前
        yield* GeometryUtility.quadPosition(center.addWith(forward), up, right.negateThis()); // 奥
        yield* GeometryUtility.quadPosition(center.addWith(up), forward, right); // 上
        yield* GeometryUtility.quadPosition(center.addWith(right), forward, up.negateThis()); // 右
        yield* GeometryUtility.quadPosition(center.subtractWith(up), forward, right.negateThis()); // 下
        yield* GeometryUtility.quadPosition(center.subtractWith(right), forward, up); // 左
    }
    static *quadPosition(center, up, right) {
        let p0 = center.subtractWith(right).addWith(up);
        let p1 = center.addWith(right).addWith(up);
        let p2 = center.addWith(right).subtractWith(up);
        let p3 = center.subtractWith(right).subtractWith(up);
        yield* p0.rawElements;
        yield* p1.rawElements;
        yield* p2.rawElements;
        yield* p3.rawElements;
    }
    static *spherePosition(center, up, right, forward, rowDiv, circleDiv) {
        yield* center.addWith(up).rawElements;
        yield* center.subtractWith(up).rawElements;
        const ia = 2 * Math.PI / circleDiv;
        const ja = Math.PI / (rowDiv + 1);
        for (let j = 1; j <= rowDiv; j++) {
            const phi = ja * j;
            const sinPhi = Math.sin(phi);
            const upVector = up.multiplyWith(Math.cos(phi));
            for (let i = 0; i < circleDiv; i++) {
                const theta = ia * i;
                yield* (right.multiplyWith(Math.cos(theta)).addWith(forward.multiplyWith(Math.sin(theta)))).multiplyWith(sinPhi).addWith(upVector).rawElements;
            }
        }
    }
    static *quadIndex(offset) {
        const o = offset;
        yield* [o, o + 2, o + 1, o, o + 3, o + 2];
    }
    static *cubeIndex(offset) {
        const s = GeometryUtility.quadSize();
        for (let i = 0; i < 6; i++) {
            yield* GeometryUtility.quadIndex(offset + s * i);
        }
    }
    static *sphereIndex(offset, rowDiv, circleDiv) {
        const getIndex = (i, j) => offset + circleDiv * j + 2 + i;
        const top = offset;
        const bottom = offset + 1;
        // upper side
        for (let i = 0; i < circleDiv - 1; i++) {
            yield top;
            yield getIndex(i, 0);
            yield getIndex(i + 1, 0);
        }
        yield* [top, getIndex(circleDiv - 1, 0), getIndex(0, 0)];
        // middle
        for (let j = 0; j < rowDiv - 1; j++) {
            for (let i = 0; i < circleDiv - 1; i++) {
                yield getIndex(i, j);
                yield getIndex(i, j + 1);
                yield getIndex(i + 1, j);
                yield getIndex(i, j + 1);
                yield getIndex(i + 1, j + 1);
                yield getIndex(i + 1, j);
            }
            yield getIndex(circleDiv - 1, j);
            yield getIndex(circleDiv - 1, j + 1);
            yield getIndex(0, j);
            yield getIndex(circleDiv - 1, j + 1);
            yield getIndex(0, j + 1);
            yield getIndex(0, j);
        }
        // lower side
        for (let i = 0; i < circleDiv - 1; i++) {
            yield bottom;
            yield getIndex(i + 1, rowDiv - 1);
            yield getIndex(i, rowDiv - 1);
        }
        yield* [bottom, getIndex(0, rowDiv - 1), getIndex(circleDiv - 1, rowDiv - 1)];
    }
    static quadSize() {
        return 4;
    }
    static cubeSize() {
        return 6 * GeometryUtility.quadSize();
    }
    static sphereSize(rowDiv, circleDiv) {
        return 2 + rowDiv * circleDiv;
    }
}
//# sourceMappingURL=GeometryUtility.js.map