import SORTPassInfoResolver from "./SORTPassInfoResolver";
import SORTPass from "./SORTPass";
import Program from "../Resource/Program";
import Shader from "../Resource/Shader";
import SORTPassParser from "./SORTPassParser";
export default class PassFactory {
    /**
     * [Instanciate SORT pass from ISORTPassInfo]
     * @param  {WebGLRenderingContext} gl       [description]
     * @param  {ISORTPassInfo}         passInfo [description]
     * @return {Promise<SORTPass>}              [description]
     */
    static fromSORTPassInfo(gl, passInfo) {
        const vs = new Shader(gl, WebGLRenderingContext.VERTEX_SHADER, passInfo.vertex);
        const fs = new Shader(gl, WebGLRenderingContext.FRAGMENT_SHADER, passInfo.fragment);
        const program = new Program(gl);
        program.update([vs, fs]);
        const registerers = [];
        for (let key in passInfo.gomlAttributes) {
            registerers.push((p, m) => passInfo.gomlAttributes[key].register(p, m.attributeValues[key], m));
        }
        const attributes = [];
        for (let key in passInfo.attributes) {
            attributes.push(key);
        }
        return new SORTPass(program, attributes, (p, args) => {
            passInfo.configurator.forEach((configurator) => configurator(p.gl)); // gl configuration
            registerers.forEach((r) => r(p.uniforms, args)); // user variables
            passInfo.systemRegisterers.forEach((r) => r(p.uniforms, args)); // system variables
        }, passInfo);
    }
    static fromSinglePassSORT(gl, src) {
        return __awaiter(this, void 0, void 0, function* () {
            const passInfo = yield PassFactory._sortPassResolver.resolve(src, () => SORTPassParser.parse(src));
            return PassFactory.fromSORTPassInfo(gl, passInfo);
        });
    }
    static passInfoFromSORT(source) {
        const passes = source.split("@Pass").filter(p => p.indexOf("@") >= 0); // Separate with @Pass and if there was some pass without containing @, that would be skipped since that is assumed as empty.
        return Promise.all(passes.map(p => SORTPassParser.parse(p)));
    }
}
PassFactory._sortPassResolver = new SORTPassInfoResolver();
//# sourceMappingURL=PassFactory.js.map