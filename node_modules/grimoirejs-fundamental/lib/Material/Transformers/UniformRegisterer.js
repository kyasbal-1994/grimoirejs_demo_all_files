import EnvUniformValueResolver from "../EnvUniformValueResolver";
function _getDecl(converter, defaultValue, register) {
    return {
        converter: converter,
        defaultValue: defaultValue,
        register: register
    };
}
// return default value if annotation containing default value. if not, return provided default value.
function _resolveDefault(vi, defaultValue) {
    if (vi.variableAnnotation.default) {
        return vi.variableAnnotation.default;
    }
    else {
        return defaultValue;
    }
}
function _registerUserUniforms(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const promises = [];
        const attributes = input.info.gomlAttributes;
        for (let variableName in input.info.uniforms) {
            if (variableName.charAt(0) === "_") {
                // this should not assigned by material argument
                continue;
            }
            const uniforms = input.info.uniforms;
            const variableInfo = uniforms[variableName];
            const annotations = variableInfo.variableAnnotation;
            if (variableInfo.isArray) {
                switch (variableInfo.variableType) {
                    case "float":
                        let defaultArray = new Array(variableInfo.arrayLength);
                        defaultArray = defaultArray.map((p) => 0);
                        attributes[variableName] = _getDecl("NumberArray", _resolveDefault(variableInfo, defaultArray), (proxy, val) => {
                            proxy.uniformFloatArray(variableName, val);
                        });
                        break;
                    default:
                        throw new Error(`Unsupported array type ${variableInfo.variableType}`);
                }
            }
            else {
                switch (variableInfo.variableType) {
                    case "bool":
                        attributes[variableName] = _getDecl("Boolean", _resolveDefault(variableInfo, false), (proxy, val) => {
                            proxy.uniformBool(variableName, val);
                        });
                        break;
                    case "float":
                        attributes[variableName] = _getDecl("Number", _resolveDefault(variableInfo, 0), (proxy, val) => {
                            proxy.uniformFloat(variableName, val);
                        });
                        break;
                    case "vec2":
                        attributes[variableName] = _getDecl("Vector2", _resolveDefault(variableInfo, "0,0"), (proxy, val) => {
                            proxy.uniformVector2(variableName, val);
                        });
                        break;
                    case "vec3":
                        if (annotations["type"] === "color") {
                            attributes[variableName] = _getDecl("Color3", _resolveDefault(variableInfo, "#000"), (proxy, val) => {
                                proxy.uniformColor3(variableName, val);
                            });
                        }
                        else {
                            attributes[variableName] = _getDecl("Vector3", _resolveDefault(variableInfo, "0,0,0"), (proxy, val) => {
                                proxy.uniformVector3(variableName, val);
                            });
                        }
                        break;
                    case "vec4":
                        if (annotations["type"] === "color") {
                            attributes[variableName] = _getDecl("Color4", _resolveDefault(variableInfo, "#0000"), (proxy, val) => {
                                proxy.uniformColor4(variableName, val);
                            });
                        }
                        else {
                            attributes[variableName] = _getDecl("Vector4", _resolveDefault(variableInfo, "0,0,0,0"), (proxy, val) => {
                                proxy.uniformVector4(variableName, val);
                            });
                        }
                        break;
                    case "sampler2D":
                        let flagAssignTo = undefined;
                        // check used flag is existing
                        if (annotations["usedFlag"]) {
                            if (annotations["usedFlag"] !== void 0) {
                                flagAssignTo = annotations["usedFlag"];
                            }
                        }
                        attributes[variableName] = _getDecl("MaterialTexture", _resolveDefault(variableInfo, undefined), (proxy, val, matArgs) => {
                            if (val) {
                                proxy.uniformTexture2D(variableName, val(matArgs.buffers));
                                if (flagAssignTo) {
                                    proxy.uniformBool(flagAssignTo, true);
                                }
                            }
                            else {
                                if (flagAssignTo) {
                                    proxy.uniformBool(flagAssignTo, false);
                                }
                            }
                        });
                        break;
                    default:
                        throw new Error("Unsupported type was found");
                }
            }
        }
        yield Promise.all(promises);
    });
}
/**
 * Register system shader variables whose name starts with _.
 * @param  {ITransformingArgument} input [description]
 * @return {Promise<void>}           [description]
 */
function _registerEnvUniforms(input) {
    const registerers = input.info.systemRegisterers;
    for (let variableName in input.info.uniforms) {
        if (variableName.charAt(0) === "_") {
            const variableInfo = input.info.uniforms[variableName];
            let resolver = EnvUniformValueResolver.resolve(variableName, variableInfo);
            if (resolver) {
                registerers.push(resolver);
                continue;
            }
            throw new Error(`Unknown environment uniform variable ${variableName}`);
        }
    }
}
export default function (input) {
    return __awaiter(this, void 0, void 0, function* () {
        yield _registerUserUniforms(input);
        _registerEnvUniforms(input);
        return input;
    });
}
//# sourceMappingURL=UniformRegisterer.js.map