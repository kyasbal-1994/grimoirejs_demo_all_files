function _removeOtherPart(source, partFlag) {
    const regex = new RegExp(`\s*(?:\/\/+)?\s*@${partFlag}`, "g");
    while (true) {
        const found = regex.exec(source);
        if (!found) {
            break; // When there was no more found
        }
        let beginPoint = found.index;
        let index = source.indexOf("{", beginPoint); // ignore next {
        const endPoint = _getEndBracketIndex(source, index, "{", "}") + 1;
        if (endPoint < 1) {
            // error no bracket matching
            console.error("Invalid bracket matching!");
            return source;
        }
        source = source.substr(0, beginPoint) + source.substring(endPoint, source.length);
    }
    return source;
}
function _removeSelfOnlyTag(source, partFlag) {
    const regex = new RegExp(`(\s*(?:\/\/+)?\s*@${partFlag})`, "g");
    while (true) {
        const found = regex.exec(source);
        if (!found) {
            break; // When there was no more found
        }
        let index = source.indexOf("{", found.index); // ignore next {
        let beginPoint = index;
        const endPoint = _getEndBracketIndex(source, index, "{", "}") + 1;
        if (endPoint < 1) {
            // error no bracket matching
            console.error("Invalid bracket matching!");
            return source;
        }
        source = source.substr(0, found.index) + source.substring(beginPoint + 1, endPoint - 1) + source.substring(endPoint + 1, source.length);
    }
    return source;
}
function _getEndBracketIndex(source, startIndex, beginBracket, endBracket) {
    // get index of matching endBracket
    let index = startIndex;
    let bracketCount = 1;
    while (true) {
        if (bracketCount === 0) {
            break;
        }
        index++;
        const nextEndBlacket = source.indexOf(endBracket, index);
        const nextBeginBlacket = source.indexOf(beginBracket, index);
        if (nextEndBlacket < 0) {
            // error no bracket matching
            console.error("Invalid bracket matching!");
            return -1;
        }
        if (nextBeginBlacket < 0) {
            index = nextEndBlacket;
            bracketCount--;
            continue;
        }
        if (nextEndBlacket < nextBeginBlacket) {
            index = nextEndBlacket;
            bracketCount--;
            continue;
        }
        else {
            index = nextBeginBlacket;
            bracketCount++;
            continue;
        }
    }
    return index;
}
export default function (input) {
    return __awaiter(this, void 0, void 0, function* () {
        let fragment = _removeSelfOnlyTag(_removeOtherPart(input.transforming, "vert"), "frag");
        let vertex = _removeSelfOnlyTag(_removeOtherPart(input.transforming, "frag"), "vert");
        input.info.fragment = fragment;
        input.info.vertex = vertex;
        return input;
    });
}
//# sourceMappingURL=ShaderSeparator.js.map