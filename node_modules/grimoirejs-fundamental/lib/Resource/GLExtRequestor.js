export default class GLExtRequestor {
    constructor(gl) {
        this.gl = gl;
        this.extensions = {};
        this._readyExtensions = {};
        this._resolveRequested();
        GLExtRequestor._requestObserver.push(this._resolveExtensionSafely);
    }
    /**
     * Request extension to use.
     * @param {string} str [description]
     */
    static request(extName, isNecessary = false) {
        const index = GLExtRequestor._requestIndexOf(extName);
        if (index > -1 && isNecessary) {
            GLExtRequestor._requestedExtensions[index] = { extensionName: extName, isNecessary: isNecessary };
        }
        else if (index === -1) {
            GLExtRequestor._requestedExtensions.push({ extensionName: extName, isNecessary: isNecessary });
        }
        GLExtRequestor._requestObserver.forEach((o) => o(extName));
    }
    static _requestIndexOf(extName) {
        for (let i = 0; i < GLExtRequestor._requestedExtensions.length; i++) {
            if (GLExtRequestor._requestedExtensions[i].extensionName === extName) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Resolve all extension requested already.
     */
    _resolveRequested() {
        GLExtRequestor._requestedExtensions.forEach((e) => {
            this._resolveExtensionSafely(e.extensionName);
        });
    }
    _resolveExtensionSafely(extName) {
        const e = GLExtRequestor._requestedExtensions[GLExtRequestor._requestIndexOf(extName)];
        if (!this._resolveExtension(e.extensionName) && e.isNecessary) {
            throw new Error(`A WebGL extension '${e.extensionName}' was requested. But that is not supported on this device.`);
        }
    }
    _resolveExtension(name) {
        if (this._readyExtensions[name]) {
            return true;
        }
        let ext;
        if (typeof GLExtRequestor._customExtensionResolvers[name] === "undefined") {
            ext = this.extensions[name] = this.gl.getExtension(name);
        }
        else {
            ext = this.extensions[name] = GLExtRequestor._customExtensionResolvers[name](this.gl);
        }
        return !!this._readyExtensions[name];
    }
}
/**
 * Extension list requested to use.
 * @type {string[]}
 */
GLExtRequestor._requestedExtensions = [];
/**
 * Some of extensions needed to override resolving extensions by this.
 */
GLExtRequestor._customExtensionResolvers = {};
GLExtRequestor._requestObserver = [];
GLExtRequestor._customExtensionResolvers["WEBGL_color_buffer_float"] = (gl) => {
    let isSupported;
    if (gl.getExtension("WEBGL_color_buffer_float") === null) {
        const fbo = gl.createFramebuffer();
        const tex = gl.createTexture();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
            isSupported = false;
        }
        else {
            isSupported = true;
        }
        gl.deleteTexture(tex);
        gl.deleteFramebuffer(fbo);
    }
    else {
        isSupported = true;
    }
    return isSupported;
};
//# sourceMappingURL=GLExtRequestor.js.map