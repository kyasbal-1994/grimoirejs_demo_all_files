import ResourceBase from "./ResourceBase";
export default class Texture2D extends ResourceBase {
    constructor(gl) {
        super(gl);
        this._texParameterChanged = true;
        this._magFilter = WebGLRenderingContext.LINEAR;
        this._minFilter = WebGLRenderingContext.LINEAR;
        this._wrapS = WebGLRenderingContext.REPEAT;
        this._wrapT = WebGLRenderingContext.REPEAT;
        this.texture = gl.createTexture();
    }
    get magFilter() {
        return this._magFilter;
    }
    set magFilter(filter) {
        if (this._magFilter !== filter) {
            this._texParameterChanged = true;
            this._magFilter = filter;
        }
    }
    get minFilter() {
        return this._minFilter;
    }
    set minFilter(filter) {
        if (this._minFilter !== filter) {
            this._texParameterChanged = true;
            this._minFilter = filter;
        }
    }
    get wrapS() {
        return this._wrapS;
    }
    set wrapS(filter) {
        if (this._wrapS !== filter) {
            this._texParameterChanged = true;
            this._wrapS = filter;
        }
    }
    get wrapT() {
        return this._wrapT;
    }
    set wrapT(filter) {
        if (this._wrapT !== filter) {
            this._texParameterChanged = true;
            this._wrapT = filter;
        }
    }
    update(levelOrImage, widthOrFlipY, height, border, format, type, pixels, flipYForBuffer) {
        this.gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, this.texture);
        let flipY = false;
        let image;
        let width;
        let level;
        if (typeof height === "undefined") {
            flipY = widthOrFlipY ? true : false;
            image = levelOrImage;
        }
        else {
            level = levelOrImage;
            width = widthOrFlipY;
        }
        this.gl.pixelStorei(WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, flipY ? 1 : 0);
        if (typeof height === "undefined") {
            this.gl.texImage2D(WebGLRenderingContext.TEXTURE_2D, 0, WebGLRenderingContext.RGBA, WebGLRenderingContext.RGBA, WebGLRenderingContext.UNSIGNED_BYTE, this._checkSize(image));
        }
        else {
            if (typeof pixels === "undefined") {
                pixels = null;
            }
            this.gl.texImage2D(WebGLRenderingContext.TEXTURE_2D, level, format, width, height, border, format, type, pixels);
        }
        this.valid = true;
    }
    register(registerNumber) {
        this.gl.activeTexture(WebGLRenderingContext.TEXTURE0 + registerNumber);
        this.gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, this.texture);
        if (this._texParameterChanged) {
            this._updateTexParameter();
        }
    }
    destroy() {
        super.destroy();
        this.gl.deleteTexture(this.texture);
    }
    // There should be more effective way to resize texture
    _checkSize(img) {
        const w = img.naturalWidth, h = img.naturalHeight;
        const size = Math.pow(2, Math.log(Math.min(w, h)) / Math.LN2 | 0); // largest 2^n integer that does not exceed s
        if (w !== h || w !== size) {
            const canv = document.createElement("canvas");
            canv.height = canv.width = size;
            canv.getContext("2d").drawImage(img, 0, 0, w, h, 0, 0, size, size);
            return canv;
        }
        return img;
    }
    _updateTexParameter() {
        this.gl.texParameteri(WebGLRenderingContext.TEXTURE_2D, WebGLRenderingContext.TEXTURE_MIN_FILTER, this._minFilter);
        this.gl.texParameteri(WebGLRenderingContext.TEXTURE_2D, WebGLRenderingContext.TEXTURE_MAG_FILTER, this._magFilter);
        this.gl.texParameteri(WebGLRenderingContext.TEXTURE_2D, WebGLRenderingContext.TEXTURE_WRAP_S, this._wrapS);
        this.gl.texParameteri(WebGLRenderingContext.TEXTURE_2D, WebGLRenderingContext.TEXTURE_WRAP_T, this._wrapT);
        this._texParameterChanged = false;
    }
}
//# sourceMappingURL=Texture2D.js.map