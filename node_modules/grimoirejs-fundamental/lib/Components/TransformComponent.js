import { Matrix, Vector3, Vector4, Quaternion } from "grimoirejs-math";
import { mat4, vec4 } from "gl-matrix";
import Component from "grimoirejs/lib/Node/Component";
/**
 * Provides object transformation like translation,rotation,scaling.
 */
export default class TransformComponent extends Component {
    constructor(...args) {
        super(...args);
        /**
         * Local transform matrix representing scaling,rotation and translation of attached object.
         * @return {[type]} [description]
         */
        this.localTransform = new Matrix();
        /**
         * Global transform that consider parent transform and local transform
         * @return {[type]} [description]
         */
        this.globalTransform = new Matrix();
        /**
         * The children transform should be notified when this transform was updated.
         * @type {TransformComponent[]}
         */
        this._children = [];
        /**
         * Calculation cache to
         * @return {[type]} [description]
         */
        this._cachePVM = new Matrix();
        /**
         * Cache of forward direction of this object
         */
        this._forward = new Vector3([0, 0, -1, 0]);
        /**
         * Cache of up direction of this object.
         */
        this._up = new Vector3([0, 1, 0, 0]);
        /**
         * Cache of right direction of this object.
         */
        this._right = new Vector3([1, 0, 0, 0]);
    }
    get position() {
        return this._position;
    }
    set position(val) {
        this._position = val;
        this.attributes.get("position").Value = val;
    }
    get rotation() {
        return this._rotation;
    }
    set rotation(val) {
        this._rotation = val;
        this.attributes.get("rotation").Value = val;
    }
    get scale() {
        return this._scale;
    }
    set scale(val) {
        this._scale = val;
        this.attributes.get("scale").Value = val;
    }
    get forward() {
        return this._forward;
    }
    get up() {
        return this._up;
    }
    get right() {
        return this._right;
    }
    calcPVW(camera) {
        mat4.mul(this._cachePVM.rawElements, camera.getProjectionViewMatrix().rawElements, this.globalTransform.rawElements);
        return this._cachePVM;
    }
    $awake() {
        // register observers
        this.attributes.get("position").addObserver(() => {
            this._position = this.attributes.get("position").Value;
            this.updateTransform();
        });
        this.attributes.get("rotation").addObserver(() => {
            this._rotation = this.attributes.get("rotation").Value;
            this.updateTransform();
        });
        this.attributes.get("scale").addObserver(() => {
            this._scale = this.attributes.get("scale").Value;
            this.updateTransform();
        });
        // assign attribute values to field
        this._position = this.attributes.get("position").Value;
        this._rotation = this.attributes.get("rotation").Value;
        this._scale = this.attributes.get("scale").Value;
        this.updateTransform();
    }
    $mount() {
        this._parentTransform = this.node.parent.getComponent("Transform");
        if (this._parentTransform) {
            this._parentTransform._children.push(this);
        }
        this.updateTransform();
    }
    $unmount() {
        if (this._parentTransform) {
            this._parentTransform._children.splice(this._parentTransform._children.indexOf(this), 1);
            this._parentTransform = null;
        }
    }
    /**
     * update local transform and global transform.
     * This need to be called if you manually edit raw elements of scale,position or rotation to recalculate transform matricies.
     */
    updateTransform() {
        mat4.fromRotationTranslationScale(this.localTransform.rawElements, this._rotation.rawElements, this._position.rawElements, this._scale.rawElements);
        this.updateGlobalTransform();
    }
    /**
     * Update global transoform.
     */
    updateGlobalTransform() {
        if (!this._parentTransform) {
            mat4.copy(this.globalTransform.rawElements, this.localTransform.rawElements);
        }
        else {
            mat4.mul(this.globalTransform.rawElements, this._parentTransform.globalTransform.rawElements, this.localTransform.rawElements);
        }
        this._updateDirections();
        this.node.sendMessage("transformUpdated", this);
        this._children.forEach((v) => v.updateGlobalTransform());
    }
    _updateDirections() {
        vec4.transformMat4(this._forward.rawElements, TransformComponent._forwardBase.rawElements, this.globalTransform.rawElements);
        vec4.transformMat4(this._up.rawElements, TransformComponent._upBase.rawElements, this.globalTransform.rawElements);
        vec4.transformMat4(this._right.rawElements, TransformComponent._rightBase.rawElements, this.globalTransform.rawElements);
    }
}
TransformComponent.attributes = {
    "position": {
        converter: "Vector3",
        defaultValue: Vector3.Zero
    },
    "rotation": {
        converter: "Rotation3",
        defaultValue: Quaternion.Identity
    },
    "scale": {
        converter: "Vector3",
        defaultValue: Vector3.One
    }
};
/**
 * Source vector to be multiplied with global transform to calculate forward direction of attached object.
 */
TransformComponent._forwardBase = new Vector4(0, 0, -1, 0);
/**
 * Source vector to be multiplied with global transform to calculate up direction of attached object.
 */
TransformComponent._upBase = new Vector4(0, 1, 0, 0);
/**
 * Source vector to be multiplied with global transform to calculate right direction of attached object.
 */
TransformComponent._rightBase = new Vector4(1, 0, 0, 0);
//# sourceMappingURL=TransformComponent.js.map