import { Quaternion, Vector3, Matrix } from "grimoirejs-math";
import Component from "grimoirejs/lib/Node/Component";
export default class MouseCameraControlComponent extends Component {
    constructor(...args) {
        super(...args);
        this._lastScreenPos = { x: NaN, y: NaN };
        this._origin = new Vector3(0, 0, 0);
        this._xsum = 0;
        this._ysum = 0;
    }
    $awake() {
        this.getAttribute("rotateX").boundTo("_rotateX");
        this.getAttribute("rotateY").boundTo("_rotateY");
        this.getAttribute("moveZ").boundTo("_moveZ");
        this.getAttribute("moveSpeed").boundTo("_moveSpeed");
        this._transform = this.node.getComponent("Transform");
        this._scriptTag = this.companion.get("canvasElement");
    }
    $mount() {
        this._scriptTag.addEventListener("mousemove", this._mouseMove.bind(this));
        this._scriptTag.addEventListener("contextmenu", this._contextMenu.bind(this));
        this._scriptTag.addEventListener("mousewheel", this._mouseWheel.bind(this));
    }
    _contextMenu(m) {
        m.preventDefault();
    }
    _mouseMove(m) {
        if (isNaN(this._lastScreenPos.x)) {
            this._initialDirection = this._transform.position.subtractWith(this._origin);
            this._initialRotation = this._transform.rotation;
            this._lastScreenPos = {
                x: m.screenX,
                y: m.screenY
            };
        }
        let updated = false;
        const diffX = m.screenX - this._lastScreenPos.x, diffY = m.screenY - this._lastScreenPos.y;
        if ((m.buttons & 1) > 0) {
            this._xsum += diffX;
            this._ysum += diffY;
            updated = true;
        }
        if ((m.buttons & 2) > 0) {
            this._origin = this._origin.addWith(this._transform.right.multiplyWith(-diffX * 0.05 * this._moveSpeed)).addWith(this._transform.up.multiplyWith(diffY * 0.05 * this._moveSpeed));
            updated = true;
        }
        if (updated) {
            const rotation = Quaternion.euler(this._ysum * 0.01, this._xsum * 0.01, 0);
            const rotationMat = Matrix.rotationQuaternion(rotation);
            const direction = Matrix.transformNormal(rotationMat, this._initialDirection);
            this._transform.position = this._origin.addWith(direction);
            this._transform.rotation = Quaternion.multiply(this._initialRotation, rotation);
        }
        this._lastScreenPos = {
            x: m.screenX,
            y: m.screenY
        };
    }
    _mouseWheel(m) {
        this._transform.position = this._transform.position.addWith(this._transform.forward.multiplyWith(m.deltaY * this._moveZ * MouseCameraControlComponent.moveCoefficient));
        m.preventDefault();
    }
}
MouseCameraControlComponent.rotateCoefficient = 0.003;
MouseCameraControlComponent.moveCoefficient = 0.05;
MouseCameraControlComponent.attributes = {
    // Specify the attributes user can intaract
    rotateX: {
        defaultValue: 1,
        converter: "Number"
    },
    rotateY: {
        defaultValue: 1,
        converter: "Number"
    },
    moveZ: {
        defaultValue: 1,
        converter: "Number"
    },
    moveSpeed: {
        defaultValue: 1,
        converter: "Number"
    }
};
//# sourceMappingURL=MouseCameraControlComponent.js.map