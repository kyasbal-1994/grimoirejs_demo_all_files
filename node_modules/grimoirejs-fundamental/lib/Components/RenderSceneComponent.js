import ResourceBase from "../Resource/ResourceBase";
import SORTPass from "../Material/SORTPass";
import Component from "grimoirejs/lib/Node/Component";
import Framebuffer from "../Resource/FrameBuffer";
export default class RenderSceneComponent extends Component {
    constructor(...args) {
        super(...args);
        this._useMaterial = false;
        this._materialArgs = {};
    }
    $awake() {
        this.getAttribute("layer").boundTo("_layer");
        this.getAttribute("clearColor").boundTo("_clearColor");
        this.getAttribute("clearColorEnabled").boundTo("_clearColorEnabled");
        this.getAttribute("clearDepthEnabled").boundTo("_clearDepthEnabled");
        this.getAttribute("clearDepth").boundTo("_clearDepth");
    }
    $mount() {
        this._gl = this.companion.get("gl");
        this._canvas = this.companion.get("canvasElement");
        if (typeof this.getValue("material") !== "undefined") {
            this._onMaterialChanged();
            this._useMaterial = true;
        }
    }
    $bufferUpdated(args) {
        const out = this.getValue("out");
        if (out !== "default") {
            this._fbo = new Framebuffer(this.companion.get("gl"));
            this._fbo.update(args.buffers[out]);
        }
        const depthBuffer = this.getValue("depthBuffer");
        if (depthBuffer && this._fbo) {
            this._fbo.update(args.buffers[depthBuffer]);
        }
    }
    $render(args) {
        if (this._fbo) {
            this._fbo.bind();
            this._gl.viewport(0, 0, args.viewport.Width, args.viewport.Height);
        }
        else {
            this._gl.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);
            this._gl.viewport(args.viewport.Left, this._canvas.height - args.viewport.Bottom, args.viewport.Width, args.viewport.Height);
        }
        // clear buffer if needed
        if (this._fbo && this._clearColorEnabled) {
            this._gl.clearColor(this._clearColor.R, this._clearColor.G, this._clearColor.B, this._clearColor.A);
            this._gl.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
        }
        if (this._clearDepthEnabled) {
            this._gl.clearDepth(this._clearDepth);
            this._gl.clear(WebGLRenderingContext.DEPTH_BUFFER_BIT);
        }
        args.camera.node.sendMessage("renderScene", {
            camera: args.camera,
            buffers: args.buffers,
            layer: this._layer,
            viewport: args.viewport,
            material: this._useMaterial ? this._material : undefined,
            materialArgs: this._useMaterial ? this._materialArgs : undefined
        });
    }
    _onMaterialChanged() {
        if (!this._materialComponent) {
            this._prepareInternalMaterial();
        }
        else {
            this._prepareExternalMaterial();
        }
    }
    _prepareExternalMaterial() {
        return __awaiter(this, void 0, void 0, function* () {
            const materialPromise = this.getValue("material");
            const loader = this.companion.get("loader");
            loader.register(materialPromise);
            const material = yield materialPromise;
            this._material = material;
        });
    }
    _prepareInternalMaterial() {
        return __awaiter(this, void 0, void 0, function* () {
            // obtain promise of instanciating material
            const materialPromise = this.getValue("material");
            const loader = this.companion.get("loader");
            loader.register(materialPromise);
            if (!materialPromise) {
                return;
            }
            const material = yield materialPromise;
            const promises = [];
            material.pass.forEach((p) => {
                if (p instanceof SORTPass) {
                    for (let key in p.programInfo.gomlAttributes) {
                        const val = p.programInfo.gomlAttributes[key];
                        this.__addAtribute(key, val);
                        this.attributes.get(key).addObserver((v) => {
                            this._materialArgs[key] = v.Value;
                        });
                        const value = this._materialArgs[key] = this.getValue(key);
                        if (value instanceof ResourceBase) {
                            promises.push(value.validPromise);
                        }
                    }
                }
            });
            yield Promise.all(promises);
            this._material = material;
        });
    }
}
RenderSceneComponent.attributes = {
    layer: {
        converter: "String",
        defaultValue: "default"
    },
    depthBuffer: {
        defaultValue: undefined,
        converter: "String"
    },
    out: {
        converter: "String",
        defaultValue: "default"
    },
    clearColor: {
        defaultValue: "#0000",
        converter: "Color4",
    },
    clearColorEnabled: {
        defaultValue: true,
        converter: "Boolean",
    },
    clearDepthEnabled: {
        defaultValue: true,
        converter: "Boolean",
    },
    clearDepth: {
        defaultValue: 1.0,
        converter: "Number",
    },
    material: {
        defaultValue: undefined,
        converter: "Material",
        componentBoundTo: "_materialComponent"
    },
};
//# sourceMappingURL=RenderSceneComponent.js.map