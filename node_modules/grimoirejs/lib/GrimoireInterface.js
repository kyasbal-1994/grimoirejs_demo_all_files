import BooleanConverter from "./Converters/BooleanConverter";
import GrimoireComponent from "./Components/GrimoireComponent";
import StringArrayConverter from "./Converters/StringArrayConverter";
import StringConverter from "./Converters/StringConverter";
import Constants from "./Base/Constants";
import ComponentDeclaration from "./Node/ComponentDeclaration";
import Component from "./Node/Component";
import NSSet from "./Base/NSSet";
import NodeDeclaration from "./Node/NodeDeclaration";
import NSIdentity from "./Base/NSIdentity";
import NSDictionary from "./Base/NSDictionary";
import GomlInterfaceGenerator from "./Interface/GomlInterfaceGenerator";
import Ensure from "./Base/Ensure";
class GrimoireInterfaceImpl {
    constructor() {
        this.nodeDeclarations = new NSDictionary();
        this.converters = new NSDictionary();
        this.componentDeclarations = new NSDictionary();
        this.rootNodes = {};
        this.loadTasks = [];
        this.nodeDictionary = {};
        this.componentDictionary = {};
        this.companion = new NSDictionary();
    }
    /**
     * Generate namespace helper function
     * @param  {string} ns namespace URI to be used
     * @return {[type]}    the namespaced identity
     */
    ns(ns) {
        return (name) => new NSIdentity(ns, name);
    }
    initialize() {
        this.registerConverter("String", StringConverter);
        this.registerConverter("StringArray", StringArrayConverter);
        this.registerConverter("Boolean", BooleanConverter);
        this.registerComponent("GrimoireComponent", GrimoireComponent);
        this.registerNode("GrimoireNodeBase", ["GrimoireComponent"]);
    }
    /**
     * Register plugins
     * @param  {(}      loadTask [description]
     * @return {[type]}          [description]
     */
    register(loadTask) {
        this.loadTasks.push(loadTask);
    }
    resolvePlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < this.loadTasks.length; i++) {
                yield this.loadTasks[i]();
            }
        });
    }
    // TODO test
    /**
     * register custom component
     * @param  {string                |   NSIdentity} name          [description]
     * @param  {IAttributeDeclaration }} attributes           [description]
     * @param  {Object                |   (new                 (}           obj           [description]
     * @return {[type]}                       [description]
     */
    registerComponent(name, obj) {
        name = Ensure.ensureTobeNSIdentity(name);
        const attrs = obj["attributes"];
        obj = this._ensureTobeComponentConstructor(obj);
        this.componentDeclarations.set(name, new ComponentDeclaration(name, attrs, obj));
    }
    registerNode(name, requiredComponents, defaultValues, superNode) {
        name = Ensure.ensureTobeNSIdentity(name);
        requiredComponents = Ensure.ensureTobeNSIdentityArray(requiredComponents);
        defaultValues = Ensure.ensureTobeNSDictionary(defaultValues, name.ns);
        superNode = Ensure.ensureTobeNSIdentity(superNode);
        this.nodeDeclarations.set(name, new NodeDeclaration(name, NSSet.fromArray(requiredComponents), defaultValues, superNode));
    }
    registerConverter(name, converter) {
        name = Ensure.ensureTobeNSIdentity(name);
        this.converters.set(name, { name: name, convert: converter });
    }
    addRootNode(tag, rootNode) {
        if (!rootNode) {
            throw new Error("can not register null to rootNodes.");
        }
        this.rootNodes[rootNode.id] = rootNode;
        rootNode.companion.set(this.ns(Constants.defaultNamespace)("scriptElement"), tag);
        // check tree constraint.
        const errorMessages = rootNode.callRecursively(n => n.checkTreeConstraints())
            .reduce((list, current) => list.concat(current)).filter(error => error);
        if (errorMessages.length !== 0) {
            const message = errorMessages.reduce((m, current) => m + "\n" + current);
            throw new Error("tree constraint is not satisfied.\n" + message);
        }
        // awake and mount tree.
        rootNode.setMounted(true);
        rootNode.broadcastMessage("treeInitialized", {
            ownerScriptTag: tag,
            id: rootNode.id
        });
        tag.setAttribute("x-rootNodeId", rootNode.id);
        return rootNode.id;
    }
    getRootNode(scriptTag) {
        const id = scriptTag.getAttribute("x-rootNodeId");
        return this.rootNodes[id];
    }
    queryRootNodes(query) {
        const scriptTags = document.querySelectorAll(query);
        const nodes = [];
        for (let i = 0; i < scriptTags.length; i++) {
            const node = this.getRootNode(scriptTags.item(i));
            if (node) {
                nodes.push(node);
            }
        }
        return nodes;
    }
    /**
     * This method is not for users.
     * Just for unit testing.
     *
     * Clear all configuration that GrimoireInterface contain.
     */
    clear() {
        this.nodeDeclarations.clear();
        this.componentDeclarations.clear();
        this.converters.clear();
        for (let key in this.rootNodes) {
            delete this.rootNodes[key];
        }
        this.loadTasks.splice(0, this.loadTasks.length);
        this.initialize();
    }
    /**
     * Ensure the given object or constructor to be an constructor inherits Component;
     * @param  {Object | (new ()=> Component} obj [The variable need to be ensured.]
     * @return {[type]}      [The constructor inherits Component]
     */
    _ensureTobeComponentConstructor(obj) {
        if (typeof obj === "function") {
            if (!(obj.prototype instanceof Component) && obj !== Component) {
                throw new Error("Component constructor must extends Component class.");
            }
        }
        else if (typeof obj === "object") {
            const newCtor = function () {
                Component.call(this);
            };
            const properties = {};
            for (let key in obj) {
                if (key === "attributes") {
                    continue;
                }
                properties[key] = { value: obj[key] };
            }
            newCtor.prototype = Object.create(Component.prototype, properties);
            Object.defineProperty(newCtor, "attributes", {
                value: obj["attributes"]
            });
            obj = newCtor;
        }
        else if (!obj) {
            obj = Component;
        }
        return obj;
    }
}
const context = new GrimoireInterfaceImpl();
const obtainGomlInterface = function (query) {
    return GomlInterfaceGenerator(context.queryRootNodes(query));
};
// const bindedFunction = obtainGomlInterface.bind(context);
Object.setPrototypeOf(obtainGomlInterface, context);
export default obtainGomlInterface;
//# sourceMappingURL=GrimoireInterface.js.map