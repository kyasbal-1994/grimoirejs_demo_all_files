import GrimoireInterface from "../GrimoireInterface";
import XMLReader from "../Base/XMLReader";
import GomlParser from "../Node/GomlParser";
import ComponentInterface from "./ComponentInterface";
/**
 * 複数のノードを対象とした操作を提供するインタフェース
 */
class NodeInterface {
    constructor(nodes) {
        this.nodes = nodes;
    }
    queryFunc(query) {
        return new ComponentInterface(this.queryComponents(query));
    }
    queryComponents(query) {
        return this.nodes.map((nodes) => {
            return nodes.map((node) => {
                const componentElements = node.componentsElement.querySelectorAll(query);
                const components = [];
                for (let i = 0; i < componentElements.length; i++) {
                    const elem = componentElements[i];
                    const component = GrimoireInterface.componentDictionary[elem.getAttribute("x-gr-id")];
                    if (component) {
                        components.push(component);
                    }
                }
                return components;
            });
        });
    }
    get(i1, i2) {
        const c = this.nodes;
        if (i1 === void 0) {
            if (c.length === 0 || c[0].length === 0) {
                return null;
            }
            else if (c.length === 1 && c[0].length === 1) {
                return c[0][0];
            }
            throw new Error("There are too many candidate");
        }
        else if (i2 === void 0) {
            if (c.length === 0 || c[0].length <= i1) {
                return null;
            }
            else if (c.length === 1 && c[0].length > i1) {
                return c[0][i1];
            }
            throw new Error("There are too many candidate");
        }
        else {
            if (c.length <= i1 || c[i1].length <= i2) {
                return null;
            }
            else {
                return c[i1][i2];
            }
        }
    }
    attr(attrName, value) {
        if (value === void 0) {
            // return Attribute.
            return this.nodes[0][0].attributes.get(attrName).Value;
        }
        else {
            // set value.
            this.forEach((node) => {
                const attr = node.attributes.get(attrName);
                if (attr.declaration.readonly) {
                    throw new Error(`The attribute ${attr.name.fqn} is readonly`);
                }
                if (attr) {
                    attr.Value = value;
                }
            });
        }
    }
    /**
     * 対象ノードにイベントリスナを追加します。
     * @param {string}   eventName [description]
     * @param {Function} listener  [description]
     */
    on(eventName, listener) {
        this.forEach((node) => {
            node.on(eventName, listener);
        });
        return this;
    }
    /**
     * 対象ノードに指定したイベントリスナが登録されていれば削除します
     * @param {string}   eventName [description]
     * @param {Function} listener  [description]
     */
    off(eventName, listener) {
        this.forEach((node) => {
            node.removeListener(eventName, listener);
        });
        return this;
    }
    /**
     * このノードインタフェースが対象とするノードそれぞれに、
     * タグで指定したノードを子要素として追加します。
     * @param {string} tag [description]
     */
    append(tag) {
        this.forEach((node) => {
            const elems = XMLReader.parseXML(tag);
            elems.forEach((elem) => GomlParser.parse(elem, node, null));
        });
        return this;
    }
    /**
     * このノードインタフェースが対象とするノードの子に、
     * 指定されたノードが存在すれば削除します。
     * @param {GomlNode} child [description]
     */
    remove(child) {
        this.forEach((node) => {
            node.removeChild(child);
        });
        return this;
    }
    /**
     * このノードインタフェースが対象とするノードに対して反復処理を行います
     * @param  {GomlNode} callback [description]
     * @return {[type]}            [description]
     */
    forEach(callback) {
        this.nodes.forEach((array) => {
            array.forEach((node) => {
                callback(node);
            });
        });
        return this;
    }
    /**
     * このノードインタフェースが対象とするノードを有効、または無効にします。
     * @param {boolean} enable [description]
     */
    setEnable(enable) {
        this.forEach((node) => {
            node.enabled = !!enable;
        });
        return this;
    }
    /**
     * このノードインタフェースにアタッチされたコンポーネントをセレクタで検索します。
     * @pram  {string}      query [description]
     * @return {Component[]}       [description]
     */
    find(query) {
        const allComponents = [];
        this.queryComponents(query).forEach((gomlComps) => {
            gomlComps.forEach((nodeComps) => {
                nodeComps.forEach((comp) => {
                    allComponents.push(comp);
                });
            });
        });
        return allComponents;
    }
    /**
     * このノードインタフェースが対象とするノードのそれぞれの子ノードを対象とする、
     * 新しいノードインタフェースを取得します。
     * @return {NodeInterface} [description]
     */
    children() {
        const children = this.nodes.map((nodes) => {
            return nodes.map((node) => {
                return node.children;
            }).reduce((pre, cur) => {
                return pre.concat(cur);
            });
        });
        return new NodeInterface(children);
    }
    /**
     * 対象ノードにコンポーネントをアタッチします。
     * @param {Component} component [description]
     */
    addCompnent(componentId) {
        this.forEach((node) => {
            const componentDec = GrimoireInterface.componentDeclarations.get(componentId);
            const comp = componentDec.generateInstance();
            node.addComponent(comp);
        });
        return this;
    }
    /**
     * 最初の対象ノードを取得する
     * @return {GomlNode} [description]
     */
    first() {
        if (this.count() === 0) {
            return null;
        }
        return this.nodes[0][0];
    }
    /**
     * 対象となる唯一のノードを取得する。
     * 対象が存在しない、あるいは複数存在するときは例外を投げる。
     * @return {GomlNode} [description]
     */
    single() {
        if (this.count() !== 1) {
            throw new Error("this nodeInterface is not single.");
        }
        return this.first();
    }
    /**
     * 対象となるノードの個数を取得する
     * @return {number} [description]
     */
    count() {
        if (this.nodes.length === 0) {
            return 0;
        }
        const counts = this.nodes.map(nodes => nodes.length);
        return counts.reduce((total, current) => total + current, 0);
    }
}
export default NodeInterface;
//# sourceMappingURL=NodeInterface.js.map