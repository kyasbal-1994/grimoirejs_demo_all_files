import NSIdentity from "./NSIdentity";
class NSDictionary {
    constructor() {
        this._nameObjectMap = new Map();
        this._fqnObjectMap = new Map();
    }
    set(key, value) {
        let namedChildMap;
        if (this._nameObjectMap.has(key.name)) {
            namedChildMap = this._nameObjectMap.get(key.name);
        }
        else {
            namedChildMap = new Map();
            this._nameObjectMap.set(key.name, namedChildMap);
        }
        namedChildMap.set(key.fqn, value);
        this._fqnObjectMap.set(key.fqn, value);
    }
    delete(key) {
        if (this._fqnObjectMap.has(key.fqn)) {
            const theMap = this._nameObjectMap.get(key.name);
            if (theMap.size === 1) {
                this._nameObjectMap.delete(key.name);
            }
            else {
                theMap.delete(key.fqn);
            }
            this._fqnObjectMap.delete(key.fqn);
        }
    }
    get(arg1, name) {
        if (typeof arg1 === "string") {
            if (name) {
                return this.get(new NSIdentity(arg1, name));
            }
            else {
                const namedMap = this._nameObjectMap.get(arg1);
                if (!namedMap) {
                    return null;
                }
                if (namedMap.size === 1) {
                    const itr = namedMap.values();
                    return itr.next().value;
                }
                else {
                    throw new Error(`Specified tag name ${arg1} is ambigious to identify.`);
                }
            }
        }
        else {
            if (arg1 instanceof NSIdentity) {
                return this.fromFQN(arg1.fqn);
            }
            else {
                if (arg1.prefix) {
                    return this.get(new NSIdentity(arg1.namespaceURI, arg1.localName));
                }
                else {
                    if (arg1.namespaceURI && this._fqnObjectMap.has(arg1.localName + "|" + arg1.namespaceURI)) {
                        return this.get(new NSIdentity(arg1.namespaceURI, arg1.localName));
                    }
                    if (arg1 && arg1.ownerElement && arg1.ownerElement.namespaceURI && this._fqnObjectMap.has(arg1.localName + "|" + arg1.ownerElement.namespaceURI)) {
                        return this.get(new NSIdentity(arg1.ownerElement.namespaceURI, arg1.localName));
                    }
                    return this.get(arg1.localName);
                }
            }
        }
    }
    fromFQN(fqn) {
        return this._fqnObjectMap.get(fqn);
    }
    isAmbigious(name) {
        return this._nameObjectMap.get(name).size > 1;
    }
    has(name) {
        return this._nameObjectMap.has(name);
    }
    pushDictionary(dict) {
        dict._fqnObjectMap.forEach((value, keyFQN) => {
            const id = NSIdentity.fromFQN(keyFQN);
            this.set(id, value);
        });
        return this;
    }
    toArray() {
        const ret = [];
        this._fqnObjectMap.forEach((value) => {
            ret.push(value);
        });
        return ret;
    }
    clone() {
        const dict = new NSDictionary();
        return dict.pushDictionary(this);
    }
    forEach(callback) {
        this._fqnObjectMap.forEach((val, key) => {
            callback(val, key);
        });
        return this;
    }
    map(callback) {
        const ret = new NSDictionary();
        this._fqnObjectMap.forEach((val, fqn) => {
            const id = NSIdentity.fromFQN(fqn);
            ret.set(id, callback(val, fqn));
        });
        return ret;
    }
    clear() {
        this._nameObjectMap.clear();
        this._fqnObjectMap.clear();
    }
}
export default NSDictionary;
//# sourceMappingURL=NSDictionary.js.map