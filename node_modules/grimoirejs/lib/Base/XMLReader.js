/**
 * Provides safe xml read feature.
 */
class XMLReader {
    static parseXML(doc, rootElementName) {
        const parsed = XMLReader._parser.parseFromString(doc, "text/xml");
        if (rootElementName) {
            if (parsed.documentElement.tagName.toUpperCase() !== rootElementName.toUpperCase()) {
                throw new Error("Specified document is invalid.");
            } // TODO should throw more detail error
        }
        return [parsed.documentElement]; // TODO: implenent!
    }
    static getElements(elem, name) {
        const result = [];
        const elems = elem.getElementsByTagName(name);
        for (let i = 0; i < elems.length; i++) {
            result.push(elems.item(i));
        }
        return result;
    }
    static getSingleElement(elem, name, mandatory) {
        const result = XMLReader.getElements(elem, name);
        if (result.length === 1) {
            return result[0];
        }
        else if (result.length === 0) {
            if (mandatory) {
                throw new Error(`The mandatory element ${name} was required, but not found`);
            }
            else {
                return null;
            }
        }
        else {
            throw new Error(`The element ${name} requires to exist in single. But there is ${result.length} count of elements`);
        }
    }
    static getAttribute(elem, name, mandatory) {
        const result = elem.attributes.getNamedItem(name);
        if (result) {
            return result.value;
        }
        else if (mandatory) {
            throw new Error(`The mandatory attribute ${name} was required, but it was not found`);
        }
        else {
            return null;
        }
    }
    static getAttributeFloat(elem, name, mandatory) {
        const resultStr = XMLReader.getAttribute(elem, name, mandatory);
        return parseFloat(resultStr);
    }
    static getAttributeInt(elem, name, mandatory) {
        const resultStr = XMLReader.getAttribute(elem, name, mandatory);
        return parseInt(resultStr, 10);
    }
    static getChildElements(elem) {
        const children = elem.childNodes;
        const result = [];
        for (let i = 0; i < children.length; i++) {
            if (children.item(i) instanceof Element) {
                result.push(children.item(i));
            }
        }
        return result;
    }
    static getAttributes(elem, ns) {
        const result = {};
        const attrs = elem.attributes;
        for (let i = 0; i < attrs.length; i++) {
            const attr = attrs.item(i);
            if (!ns || attr.namespaceURI === ns) {
                result[attr.localName] = attr.value;
            }
        }
        return result;
    }
}
XMLReader._parser = new DOMParser();
export default XMLReader;
//# sourceMappingURL=XMLReader.js.map