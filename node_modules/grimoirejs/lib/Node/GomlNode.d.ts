import EEObject from "../Base/EEObject";
import Component from "./Component";
import NodeDeclaration from "./NodeDeclaration";
import Attribute from "./Attribute";
import NSDictionary from "../Base/NSDictionary";
import NSIdentity from "../Base/NSIdentity";
import IGomlInterface from "../Interface/IGomlInterface";
declare class GomlNode extends EEObject {
    element: Element;
    nodeDeclaration: NodeDeclaration;
    children: GomlNode[];
    attributes: NSDictionary<Attribute>;
    componentsElement: Element;
    private _parent;
    private _root;
    private _mounted;
    private _components;
    private _messageBuffer;
    private _tree;
    private _companion;
    private _deleted;
    private _attrBuffer;
    readonly name: NSIdentity;
    /**
     * このノードの属するツリーのGomlInterface。unmountedならnull。
     * @return {IGomlInterface} [description]
     */
    readonly tree: IGomlInterface;
    readonly deleted: boolean;
    readonly isActive: boolean;
    enabled: boolean;
    /**
     * ツリーで共有されるオブジェクト。マウントされていない状態ではnull。
     * @return {NSDictionary<any>} [description]
     */
    readonly companion: NSDictionary<any>;
    readonly nodeName: NSIdentity;
    readonly parent: GomlNode;
    /**
     * Get mounted status.
     * @return {boolean} Whether this node is mounted or not.
     */
    readonly mounted: boolean;
    /**
     * 新しいインスタンスの作成
     * @param  {NodeDeclaration} recipe  作成するノードのDeclaration
     * @param  {Element}         element 対応するDomElement
     * @return {[type]}                  [description]
     */
    constructor(recipe: NodeDeclaration, element: Element);
    /**
     * ノードを削除する。使わなくなったら呼ぶ。子要素も再帰的に削除する。
     */
    delete(): void;
    sendMessage(message: string, args?: any): boolean;
    /**
     * [broadcastMessage description]
     * @param {number} range 0でそのノードのみ、1で子要素,2で孫...
     * @param {string} name  [description]
     * @param {any}    args  [description]
     */
    broadcastMessage(range: number, name: string, args?: any): void;
    broadcastMessage(name: string, args?: any): void;
    /**
     * 指定したノード名と属性で生成されたノードの新しいインスタンスを、このノードの子要素として追加
     * @param {string |   NSIdentity} nodeName      [description]
     * @param {any    }} attributes   [description]
     */
    addNode(nodeName: string | NSIdentity, attributes: {
        [attrName: string]: any;
    }): void;
    /**
     * Add child.
     * @param {GomlNode} child            追加する子ノード
     * @param {number}   index            追加位置。なければ末尾に追加
     * @param {[type]}   elementSync=true trueのときはElementのツリーを同期させる。（Elementからパースするときはfalseにする）
     */
    addChild(child: GomlNode, index?: number, elementSync?: boolean): void;
    callRecursively<T>(func: (g: GomlNode) => T): T[];
    /**
     * デタッチしてdeleteする。
     * @param {GomlNode} child Target node to be inserted.
     */
    removeChild(child: GomlNode): void;
    /**
     * 指定したノードが子要素なら子要素から外す。
     * @param  {GomlNode} child [description]
     * @return {GomlNode}       [description]
     */
    detachChild(target: GomlNode): GomlNode;
    /**
     * detach myself
     */
    detach(): void;
    attr(attrName: string | NSIdentity): any;
    attr(attrName: string | NSIdentity, value: any): void;
    /**
     *  Add new attribute. In most of case, users no need to call this method.
     *  Use __addAttribute in Component should be used instead.
     */
    addAttribute(attr: Attribute): void;
    /**
     * Update mounted status and emit events
     * @param {boolean} mounted Mounted status.
     */
    setMounted(mounted: boolean): void;
    /**
     * Get index of this node from parent.
     * @return {number} number of index.
     */
    index(): number;
    removeAttribute(attr: Attribute): void;
    /**
     * このノードにコンポーネントをアタッチする。
     * @param {Component} component [description]
     */
    addComponent(component: Component): void;
    addComponent(component: string): void;
    getComponents(): Component[];
    getComponent(name: string | NSIdentity): Component;
    /**
     * すべてのコンポーネントの属性をエレメントかデフォルト値で初期化
     */
    resolveAttributesValue(): void;
    /**
     * このノードのtreeConstrainが満たされるか調べる
     * @return {string[]} [description]
     */
    checkTreeConstraints(): string[];
    /**
     * バッファしていたmount,unmountが送信されるかもしれない.アクティブなら
     */
    notifyActivenessUpdate(): void;
    /**
     * コンポーネントにメッセージを送る。送信したらバッファからは削除される.
     * @param  {Component} targetComponent 対象コンポーネント
     * @param  {string}    message         メッセージ
     * @param  {boolean}   forced          trueでコンポーネントのenableを無視して送信
     * @param  {boolean}   toBuffer        trueで送信失敗したらバッファに追加
     * @param  {any}       args            [description]
     * @return {boolean}                   送信したか
     */
    private _sendMessageToComponent(targetComponent, message, forced, toBuffer, args?);
    /**
     * バッファからメッセージを送信。成功したらバッファから削除
     * @param  {Component} target  [description]
     * @param  {string}    message [description]
     * @param  {boolean}   forced  [description]
     * @param  {any}       args    [description]
     * @return {boolean}           成功したか
     */
    private _sendBufferdMessageToComponent(target, message, forced, sendToRemove, args?);
    private _sendMessage(message, forced, toBuffer, args?);
    /**
     * バッファのメッセージを送信可能なら送信してバッファから削除
     */
    private _sendBufferdMessage(message, forced, args?);
    private _clearMessageBuffer(message);
    private _callRecursively<T>(func, nextGenerator);
}
export default GomlNode;
